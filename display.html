<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Registrar Queue Display</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="display.css" />
</head>
<body>
  <h1>Registrar Queue Display</h1>

  <div class="grid" id="grid">
    <div class="col" data-service="registrar">
      <h2>Registrar</h2>
      <div class="meta" id="meta-registrar">Called: —  Waiting: 0</div>
      <div id="called-registrar"></div>
      <div class="waiting-list" id="list-registrar"></div>
    </div>

    <div class="col" data-service="cashier">
      <h2>Cashier</h2>
      <div class="meta" id="meta-cashier">Called: —  Waiting: 0</div>
      <div id="called-cashier"></div>
      <div class="waiting-list" id="list-cashier"></div>
    </div>

    <div class="col" data-service="admissions">
      <h2>Admissions</h2>
      <div class="meta" id="meta-admissions">Called: —  Waiting: 0</div>
      <div id="called-admissions"></div>
      <div class="waiting-list" id="list-admissions"></div>
    </div>

    <div class="col" data-service="records">
      <h2>Records</h2>
      <div class="meta" id="meta-records">Called: —  Waiting: 0</div>
      <div id="called-records"></div>
      <div class="waiting-list" id="list-records"></div>
    </div>
  </div>

  <div id="debug">Debug messages will appear here</div>

<script>
    let API = 'http://192.168.18.34:4000'; // http://localhost:4000 API Doesn't return json???? it returns html???? wtf (fix issue since display will not work)
                                      // but it worked on kiosk so idk and worked the first time before i changed something probably fucked up json parse
                                      // logic when fetching /queue
    if (window.location.port === '5173') API = 'http://192.168.18.34:4000';

const SERVICES = ['registrar','cashier','admissions','records'];
const debugBox = document.getElementById('debug');
function dbg(msg){ const p = document.createElement('div'); p.textContent = new Date().toLocaleTimeString() + ' — ' + msg; debugBox.insertBefore(p, debugBox.firstChild); console.log('[display]',msg); }

/* helper: ensure services field is an array */
function parseServicesField(s) {
  if (!s) return [];
  if (Array.isArray(s)) return s;
  try {
    const parsed = JSON.parse(s);
    if (Array.isArray(parsed)) return parsed;
  } catch(e){}
  // fallback: comma separated string
  if (typeof s === 'string') return s.split(',').map(x => x.trim()).filter(Boolean);
  return [];
}

/* Render helpers */
function renderCalled(ticket, service) {
  const prefix = { registrar:'R', cashier:'C', admissions:'A', records:'D' }[service] || '';
  const tokenText = prefix + String(ticket.id).padStart(3,'0');
  const html = `
    <div class="called">
      <div class="token-big">${tokenText}</div>
      <div class="info">
        <div class="name">${ticket.name || 'Guest'}</div>
        <div class="type">${ticket.quer_type || ''} • ${ticket.status || ''}</div>
      </div>
    </div>`;
  return html;
}
function renderWaitingLine(ticket) {
  const id = String(ticket.id).padStart(3,'0');
  const name = ticket.name || '';
  const type = ticket.quer_type || '';
  return `<div class="wait-item" data-id="${ticket.id}"><div class="wait-left"><div class="wait-id">${id}</div><div><div class="wait-name">${name}</div><div class="wait-type">${type}</div></div></div><div class="small">${ticket.status}</div></div>`;
}

/* Main render: accepts array of ticket objects from /queue */
function renderQueue(arr) {
  // clear all columns
  SERVICES.forEach(s => {
    document.getElementById('called-' + s).innerHTML = '';
    document.getElementById('list-' + s).innerHTML = '';
    document.getElementById('meta-' + s).textContent = 'Called: —  Waiting: 0';
  });

  // compute waiting counts and display called items
  const waitingCounts = { registrar:0, cashier:0, admissions:0, records:0 };

  // 1) display called tickets (only on their called_service)
  arr.forEach(t => {
    if (t.status === 'called' && t.called_service) {
      const s = t.called_service;
      const container = document.getElementById('called-' + s);
      if (container) container.insertAdjacentHTML('beforeend', renderCalled(t, s));
    }
  });

  // 2) display waiting tickets under each service they signed for
    arr.forEach(t => {
    // if this ticket is already called by any service, skip it entirely for waiting
    if (t.status === 'called' && t.called_service) return;

    if (t.status === 'waiting') {
        const services = parseServicesField(t.services);
        services.forEach(s => {
        // skip if another service already called this ticket
        if (t.called_service && t.called_service !== s) return;
        const container = document.getElementById('list-' + s);
        if (!container) return;
        container.insertAdjacentHTML('beforeend', renderWaitingLine(t));
        waitingCounts[s] = (waitingCounts[s] || 0) + 1;
        });
    }
    });

  // update meta
  SERVICES.forEach(s => {
    const calledEl = document.querySelector(`#called-${s} .token-big`);
    const calledText = calledEl ? calledEl.textContent : '—';
    document.getElementById('meta-' + s).textContent = `Called: ${calledText}  Waiting: ${waitingCounts[s] || 0}`;
  });
}

/* Fetch queue robustly and render */
async function fetchQueue() {
  dbg('Fetching ' + API + '/queue');
  try {
    const resp = await fetch(API + '/queue', { cache: 'no-store' });
    const text = await resp.text();
    if (!resp.ok) {
      dbg('HTTP ' + resp.status + ' from /queue');
      dbg(text.slice(0,300));
      return;
    }
    // ensure it parsed as JSON, quick fix for issue where it returns html, but might break other stuff? maybe not idk hope nalang
    let arr;
    try { arr = JSON.parse(text); }
    catch(e) { dbg('Parse error: /queue returned non-JSON (snippet): ' + text.slice(0,200)); return; }
    if (!Array.isArray(arr)) { dbg('/queue returned non-array JSON'); return; }
    renderQueue(arr);
    dbg('Rendered ' + arr.length + ' tickets');
  } catch (err) {
    dbg('Network error fetching /queue: ' + err);
  }
}

/* SSE connection for live updates, fallback to polling */
let es, poll;
function startSSE(){
  try {
    es = new EventSource(API + '/events');
    es.onopen = () => dbg('SSE open');
    es.onmessage = e => { dbg('SSE message'); fetchQueue(); };
    ['created','called','served','deleted','hold','recalled'].forEach(ev => {
      es.addEventListener(ev, e => { dbg('SSE event: ' + ev + ' payload: ' + e.data); fetchQueue(); });
    });
    es.onerror = err => { dbg('SSE error, fallback to polling'); if(es) es.close(); startPolling(); };
  } catch(e) { dbg('SSE start failed: ' + e); startPolling(); }
}
function startPolling(){ if(poll) clearInterval(poll); fetchQueue(); poll = setInterval(fetchQueue, 4000); }

es = new EventSource(API + '/events');
es.onopen = () => dbg('SSE open');
es.onmessage = e => { dbg('SSE message'); fetchQueue(); };

// <<< add these listeners here >>>
es.addEventListener('served', e => { console.log('served event', e.data); fetchQueue(); });
es.addEventListener('moved',  e => { console.log('moved event',  e.data); fetchQueue(); });

// (existing named event listeners can remain)
['created','called','deleted','reassigned'].forEach(ev =>
  es.addEventListener(ev, e => { dbg('SSE ' + ev + ' ' + e.data); fetchQueue(); })
);

/* init */
fetchQueue();
startSSE();
</script>
</body>
</html>
