<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Registrar Queue Display</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* Minimal display styles - dark theme */
    body { background:#0b0b0b; color:#fff; font-family: Arial, Helvetica, sans-serif; margin:18px; }
    h1 { font-size:48px; margin-bottom:18px; color:#fff; }
    .grid { display:flex; gap:18px; align-items:flex-start; }
    .col { flex:1; min-width:260px; background:#111; padding:18px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.6); }
    .col h2 { margin:0 0 8px 0; text-align:center; font-size:18px; letter-spacing:0.06em; }
    .meta { font-size:13px; color:#bbb; text-align:center; margin-bottom:12px; }
    .slot { background:#151515; padding:18px; border-radius:8px; margin-bottom:12px; display:flex; align-items:center; gap:12px; }
    .token { font-size:72px; font-weight:800; color:#fff; min-width:140px; text-align:center; }
    .info { flex:1; }
    .info .name { color:#9fb8d9; font-size:20px; margin-bottom:6px; }
    .info .type { color:#cfd8e6; font-size:14px; }
    .list-placeholder { background:#121212; padding:12px; border-radius:6px; color:#9aa; text-align:center; }
    .small { font-size:13px; color:#9aa; }
    .footer { position:fixed; right:18px; top:18px; color:#9aa; font-size:12px; }
  </style>
</head>
<body>
  <h1>Registrar Queue Display</h1>
  <div class="footer">Auto-updates: SSE + Polling fallback</div>

  <div class="grid" id="grid">
    <!-- Four columns: registrar, cashier, admissions, records -->
    <div class="col" data-service="registrar">
      <h2>Registrar</h2>
      <div class="meta" id="meta-registrar">Called: — &nbsp; Waiting: 0</div>
      <div id="list-registrar"></div>
    </div>

    <div class="col" data-service="cashier">
      <h2>Cashier</h2>
      <div class="meta" id="meta-cashier">Called: — &nbsp; Waiting: 0</div>
      <div id="list-cashier"></div>
    </div>

    <div class="col" data-service="admissions">
      <h2>Admissions</h2>
      <div class="meta" id="meta-admissions">Called: — &nbsp; Waiting: 0</div>
      <div id="list-admissions"></div>
    </div>

    <div class="col" data-service="records">
      <h2>Records</h2>
      <div class="meta" id="meta-records">Called: — &nbsp; Waiting: 0</div>
      <div id="list-records"></div>
    </div>
  </div>

<script>
const API = window.location.origin;
const SERVICES = ['registrar','cashier','admissions','records'];

// Utility to render slot HTML
function renderSlot(ticket, displayToken) {
  const tokenText = displayToken || (ticket.token ? ticket.token : String(ticket.id).padStart(3,'0'));
  const quer = ticket.quer_type || '';
  return `
    <div class="slot" data-id="${ticket.id}" data-service="${ticket.called_service || ''}">
      <div class="token">${tokenText}</div>
      <div class="info">
        <div class="name">${ticket.name || 'Guest'} <span style="font-size:14px;color:#7fa0c8"> ${quer ? '('+quer+')' : ''}</span></div>
        <div class="type small">${ticket.status || ''}</div>
      </div>
    </div>`;
}

// Keep an in-memory map of called tokens per service for quick UI update
const state = {
  // service -> { called: tokenString or null, waitingCount }
};

// initialize state
SERVICES.forEach(s => state[s] = { called: null, waiting: 0 });

// fetch full queue and rebuild UI (fallback)
async function fetchQueue() {
  try {
    const resp = await fetch(API + '/queue');
    const arr = await resp.json();
    // compute per-service waiting counts and called tokens
    const waitingMap = {};
    SERVICES.forEach(s => waitingMap[s]=0);

    // clear lists first
    SERVICES.forEach(s => {
      document.getElementById('list-' + s).innerHTML = '';
      state[s].called = null;
    });

    for (const t of arr) {
      // ensure services parsed
      let sv = [];
      try { sv = JSON.parse(t.services || '[]'); } catch(e) { sv = []; }
      // count waiting for each service
      if (t.status === 'waiting') {
        sv.forEach(s => waitingMap[s] = (waitingMap[s]||0)+1);
      }
      // if called, display on called_service only
      if (t.status === 'called' && t.called_service) {
        const s = t.called_service;
        const prefix = {
          registrar: 'R', cashier: 'C', admissions: 'A', records: 'D'
        }[s] || '';
        const displayToken = prefix + String(t.id).padStart(3,'0');
        state[s].called = displayToken;
        // append called ticket at top for that service
        const container = document.getElementById('list-' + s);
        if (container) container.innerHTML = renderSlot(t, displayToken) + container.innerHTML;
      } else if (t.status === 'waiting') {
        // append waiting entries under the service column as compact lines
        sv.forEach(s => {
          const container = document.getElementById('list-' + s);
          if (!container) return;
          const el = document.createElement('div');
          el.className = 'slot';
          el.innerHTML = `<div style="width:64px;font-weight:700">${String(t.id).padStart(3,'0')}</div><div style="padding-left:8px">${t.name || ''} <div class="small" style="color:#9aa">${t.status}</div></div>`;
          container.appendChild(el);
        });
      }
    }

    // update meta
    SERVICES.forEach(s => {
      const meta = document.getElementById('meta-' + s);
      meta.textContent = `Called: ${state[s].called || '—'}  Waiting: ${waitingMap[s] || 0}`;
    });

  } catch (e) {
    console.error('fetchQueue error', e);
  }
}

// SSE setup
let es;
function startSSE() {
  try {
    es = new EventSource(API + '/events');
    es.addEventListener('created', ev => fetchQueue());
    es.addEventListener('called', ev => {
      const d = JSON.parse(ev.data);
      // clear existing display for that service and show new called token only
      const s = d.service;
      const container = document.getElementById('list-' + s);
      if (!container) return;
      container.innerHTML = renderSlot(d, d.displayToken || d.token) + ''; // show called on top
      // update meta
      const meta = document.getElementById('meta-' + s);
      meta.textContent = `Called: ${d.displayToken || '—'} Waiting: (updated)`;
    });
    es.addEventListener('served', ev => {
      const d = JSON.parse(ev.data);
      // remove from service column where it was called
      // best approach: re-fetch queue to be safe
      fetchQueue();
    });
    es.addEventListener('deleted', ev => fetchQueue());
    es.addEventListener('hold', ev => fetchQueue());
    es.addEventListener('recalled', ev => fetchQueue());
    es.onerror = (err) => {
      console.warn('SSE error, falling back to polling', err);
      if (es) es.close();
      es = null;
      // start polling if SSE fails
      startPolling();
    };
  } catch (e) {
    console.error('SSE start failed', e);
    startPolling();
  }
}

let pollingInterval;
function startPolling(){
  if (pollingInterval) clearInterval(pollingInterval);
  fetchQueue();
  pollingInterval = setInterval(fetchQueue, 5000);
}

// init
fetchQueue();
startSSE();
</script>
</body>
</html>
