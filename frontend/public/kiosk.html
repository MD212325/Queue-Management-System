<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Take a Token (Kiosk)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel"icon" href="./sti-yellow-background.png"/>
  <style>
    :root{
      --card-bg:#fff;
      --svc-bg:#f9f9f9;
      --btn-bg:#ffd100;
      --btn-color:#0b4ea2;
    }
    body{font-family:Inter,Arial,Helvetica,sans-serif;margin:0;padding:18px;background:#ffffff;color:#111}
    .card{max-width:520px;margin:18px auto;padding:18px;border-radius:12px;border:1px solid #eee;background:var(--card-bg);box-shadow:0 6px 20px rgba(0,0,0,0.06);}
    .card-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
    h2{margin:0 0 8px;font-weight:700}
    .STI-LOGO {text-align:right;margin-bottom:12px}
    .STI-LOGO img{max-width:80px;height:auto;}
    label{font-weight:600;margin-top:12px;display:block}
    input[type="text"], select{width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;margin-top:6px;box-sizing:border-box}
    .hint{font-size:13px;color:#666;margin-bottom:12px}
    #svc-list{display:flex;flex-direction:column;gap:8px}
    .svc-row{
      display:flex;align-items:center;gap:10px;padding:10px;border-radius:8px;background:var(--svc-bg);border:1px solid #e6e6e6;
      user-select:none; touch-action:none;
    }
    .svc-row .svc-handle{width:28px;height:28px;border-radius:6px;background:#fff;border:1px solid #ddd;display:flex;align-items:center;justify-content:center;font-size:14px;cursor:grab}
    .svc-row .svc-check{transform:scale(1.1)}
    .svc-title{flex:1;font-weight:600}
    .svc-controls{display:flex;gap:6px}
    .svc-controls button{padding:6px 8px;border-radius:6px;border:1px solid #ddd;background:#fff;cursor:pointer}
    .btn{display:inline-block;padding:10px 12px;border-radius:8px;background:var(--btn-bg);color:var(--btn-color);border:none;font-weight:700;width:100%;box-shadow:0 3px 8px rgba(0,0,0,0.08)}
    #resultBar{margin-top:12px;padding:10px;border-radius:6px;background:linear-gradient(90deg,#ffd66b,#bfe0ff);color:#002b66;display:none; font-weight:600}
    #statusBox{margin-top:12px;padding:10px;border-radius:6px;background:#f1f8ff;color:#002b66;display:none}
    .disabled{opacity:0.6;pointer-events:none}

    /* ghost & placeholder visuals */
    .ghost {
      position:fixed;
      pointer-events:none;
      z-index:9999;
      width:calc(var(--row-width,320px));
      transform:translate(-6px,-6px) scale(1.02);
      box-shadow:0 10px 30px rgba(0,0,0,0.25);
      opacity:0.98;
      transition:transform 120ms ease;
      border-radius:8px;
      background:#fff;
    }
    .placeholder {
      height:48px;
      border-radius:8px;
      border:2px dashed #cbd5e1;
      background:linear-gradient(0deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02));
      margin:0;
    }

    /* toast */
    .toast {
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:36px;
      background:#111;
      color:#fff;
      padding:12px 16px;
      border-radius:8px;
      box-shadow:0 8px 24px rgba(0,0,0,0.35);
      z-index:10000;
      display:none;
      font-weight:600;
    }

    /* responsive */
    @media (max-width:520px){
      .card{margin:12px;padding:14px}
      .svc-row{padding:12px}
    }
  </style>
</head>
<body>
  <div class="card" id="kiosk-card">
    <div class="card-header">
        <h2>Take a Token</h2>
        <div class="STI-LOGO">
            <a href="https://www.sti.edu/" class="STI-LOGO"><img src="sti-logo.png" alt="STI College Logo"/></a>
        </div>
    </div>

    <div class="hint">Select which services you want, then order them (first → last). You can drag rows, use the ↑/↓ buttons, or touch-and-drag on phones.</div>

    <div id="resultBar" role="status"></div>

    <div id="svc-list" aria-label="Services list">
      <div class="svc-row" data-svc="registrar" draggable="false">
        <div class="svc-handle" aria-hidden="true">≡</div>
        <input type="checkbox" class="svc-check" checked />
        <div class="svc-title">Registrar</div>
        <div class="svc-controls">
          <button class="up" aria-label="Move up">↑</button>
          <button class="down" aria-label="Move down">↓</button>
        </div>
      </div>

      <div class="svc-row" data-svc="cashier" draggable="false">
        <div class="svc-handle" aria-hidden="true">≡</div>
        <input type="checkbox" class="svc-check" checked />
        <div class="svc-title">Cashier</div>
        <div class="svc-controls">
          <button class="up">↑</button><button class="down">↓</button>
        </div>
      </div>

      <div class="svc-row" data-svc="admissions" draggable="false">
        <div class="svc-handle" aria-hidden="true">≡</div>
        <input type="checkbox" class="svc-check" checked />
        <div class="svc-title">Admissions</div>
        <div class="svc-controls">
          <button class="up">↑</button><button class="down">↓</button>
        </div>
      </div>

      <div class="svc-row" data-svc="records" draggable="false">
        <div class="svc-handle" aria-hidden="true">≡</div>
        <input type="checkbox" class="svc-check" checked />
        <div class="svc-title">Records</div>
        <div class="svc-controls">
          <button class="up">↑</button><button class="down">↓</button>
        </div>
      </div>
    </div>

    <label style="display:block;margin-top:12px">Name (optional)</label>
    <input id="name" type="text" placeholder="Your name" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc">

    <label style="display:block;margin-top:12px">Type</label>
    <select id="quer" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc">
      <option>Student</option><option>Faculty/Staff</option><option>Visitor</option><option>Other</option>
    </select>

    <button id="get" class="btn" style="margin-top:16px">Get Token</button>

    <div id="statusBox" style="margin-top:12px;"></div>

    <div style="margin-top:12px">
      <button id="cancelBtn" style="display:none;background:#d9534f;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer">Cancel Ticket</button>
    </div>
  </div>

  <div class="toast" id="toast">Notification</div>

<script>
/* ---------------- configuration ---------------- */
const API = (window.location.port && window.location.port === '5173') ? 'http://192.168.18.34:4000' : window.location.origin;
const TICKET_STORE_KEY = 'kiosk_current_ticket';
const POLL_INTERVAL_MS = 6000; // update position every 6s

/* ---------- helper DOM / util ---------- */
const list = document.getElementById('svc-list');
const btnGet = document.getElementById('get');
const statusBox = document.getElementById('statusBox');
const resultBar = document.getElementById('resultBar');
const cancelBtn = document.getElementById('cancelBtn');
const toast = document.getElementById('toast');

function getSelectedOrderedServices(){
  return Array.from(list.querySelectorAll('.svc-row'))
    .filter(it => it.querySelector('.svc-check').checked)
    .map(it => it.dataset.svc);
}

function saveTicket(obj){
  localStorage.setItem(TICKET_STORE_KEY, JSON.stringify(obj));
}
function loadTicket(){
  try { return JSON.parse(localStorage.getItem(TICKET_STORE_KEY) || 'null'); } catch(e){ return null; }
}
function clearTicket(){
  localStorage.removeItem(TICKET_STORE_KEY);
}

/* ----- up/down controls ----- */
function bindUpDown(){
  list.querySelectorAll('.up').forEach(btn => btn.onclick = e => {
    const row = e.target.closest('.svc-row');
    const prev = row.previousElementSibling;
    if(prev) row.parentNode.insertBefore(row, prev);
  });
  list.querySelectorAll('.down').forEach(btn => btn.onclick = e => {
    const row = e.target.closest('.svc-row');
    const next = row.nextElementSibling;
    if(next) row.parentNode.insertBefore(next, row);
  });
}
bindUpDown();

/* ----------------- drag code (pointer-based) ----------------- */
let dragging = null, ghost=null, placeholder=null, offsetY=0, rowWidth=0;

function createGhost(row, pageX, pageY){
  ghost = row.cloneNode(true);
  ghost.classList.add('ghost');
  rowWidth = Math.min(520, list.getBoundingClientRect().width || 320);
  ghost.style.setProperty('--row-width', rowWidth + 'px');
  ghost.style.width = rowWidth + 'px';
  ghost.style.left = (pageX - 10) + 'px';
  ghost.style.top = (pageY - offsetY) + 'px';
  document.body.appendChild(ghost);
  ghost.querySelectorAll('button,input,select').forEach(el => el.disabled = true);
}
function createPlaceholder(height){
  placeholder = document.createElement('div');
  placeholder.className = 'placeholder';
  placeholder.style.height = (height)+'px';
  return placeholder;
}

function onPointerDown(e){
  const handle = e.target.closest('.svc-handle');
  const row = e.target.closest('.svc-row');
  if(!row) return;

  // allow checkbox click without starting drag
  if(!handle && e.target.closest('.svc-check')) return;

  e.preventDefault();
  dragging = row;
  const rect = row.getBoundingClientRect();
  const pageY = ('touches' in e && e.touches && e.touches[0]) ? e.touches[0].pageY : (e.pageY || e.clientY);
  offsetY = pageY - rect.top;
  const ph = createPlaceholder(rect.height);
  row.parentNode.insertBefore(ph, row);
  row.style.display = 'none';
  createGhost(row, (e.pageX || (e.touches && e.touches[0].pageX)), pageY);

  if(e.pointerId && e.target.setPointerCapture) {
    try { e.target.setPointerCapture(e.pointerId); } catch(err) {}
  }
  if(window.PointerEvent){
    document.addEventListener('pointermove', onPointerMove);
    document.addEventListener('pointerup', onPointerUp);
    document.addEventListener('pointercancel', onPointerUp);
  } else {
    document.addEventListener('touchmove', onPointerMove, {passive:false});
    document.addEventListener('touchend', onPointerUp);
    document.addEventListener('touchcancel', onPointerUp);
    document.addEventListener('mousemove', onPointerMove);
    document.addEventListener('mouseup', onPointerUp);
  }
}

function onPointerMove(e){
  if(!dragging || !ghost || !placeholder) return;
  if(e.cancelable) e.preventDefault();
  const touch = (e.touches && e.touches[0]) || e;
  const pageY = touch.pageY, pageX = touch.pageX;
  ghost.style.left = (pageX - 10) + 'px';
  ghost.style.top = (pageY - offsetY) + 'px';

  const rows = Array.from(list.querySelectorAll('.svc-row')).filter(r => r !== dragging);
  let inserted = false;
  for(const r of rows){
    const rect = r.getBoundingClientRect();
    const mid = rect.top + rect.height/2;
    if(pageY < mid){
      if(placeholder.nextSibling !== r) list.insertBefore(placeholder, r);
      inserted = true;
      break;
    }
  }
  if(!inserted){
    if(list.lastElementChild !== placeholder) list.appendChild(placeholder);
  }
}

function onPointerUp(e){
  if(!dragging) return;
  if(ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);
  if(placeholder && placeholder.parentNode){
    placeholder.parentNode.insertBefore(dragging, placeholder);
    placeholder.parentNode.removeChild(placeholder);
  } else {
    list.appendChild(dragging);
  }
  dragging.style.display = '';
  ghost = null; placeholder = null; dragging = null; offsetY = 0;

  if(window.PointerEvent){
    document.removeEventListener('pointermove', onPointerMove);
    document.removeEventListener('pointerup', onPointerUp);
    document.removeEventListener('pointercancel', onPointerUp);
  } else {
    document.removeEventListener('touchmove', onPointerMove);
    document.removeEventListener('touchend', onPointerUp);
    document.removeEventListener('touchcancel', onPointerUp);
    document.removeEventListener('mousemove', onPointerMove);
    document.removeEventListener('mouseup', onPointerUp);
  }

  bindUpDown();
}

function bindDrag(){
  list.querySelectorAll('.svc-row').forEach(row => {
    const handle = row.querySelector('.svc-handle') || row;
    if(window.PointerEvent){
      handle.removeEventListener('pointerdown', onPointerDown);
      handle.addEventListener('pointerdown', onPointerDown);
    } else {
      handle.removeEventListener('touchstart', onPointerDown);
      handle.removeEventListener('mousedown', onPointerDown);
      handle.addEventListener('touchstart', function(e){ onPointerDown(e); }, {passive:false});
      handle.addEventListener('mousedown', function(e){ onPointerDown(e); });
    }
  });
}
bindDrag();

/* ------------------ normalization helper (fix 1-based vs 0-based) ------------------ */
function normalizeIndex(service_index, services) {
  if (typeof service_index === 'undefined' || service_index === null) return undefined;
  const n = Number(service_index);
  if (!Number.isFinite(n)) return undefined;
  if (Array.isArray(services) && n >= 1 && n <= services.length) {
    return Math.max(0, n - 1);
  }
  return Math.max(0, Math.floor(n));
}

/* ------------------ UI / ticket helpers ------------------ */
function setUIForTicket(ticket) {
  if(!ticket) {
    resultBar.style.display = 'none';
    statusBox.style.display = 'none';
    cancelBtn.style.display = 'none';
    btnGet.disabled = false;
    btnGet.classList.remove('disabled');
    return;
  }
  resultBar.style.display = 'block';
  resultBar.textContent = ticket.displayText || (`Your token: ${String(ticket.id).padStart(3,'0')}`);
  statusBox.style.display = 'block';
  const pos = (typeof ticket._position !== 'undefined') ? ` — position: ${ticket._position}` : '';
  statusBox.innerHTML = `<div style="font-weight:600">Your token: ${String(ticket.id).padStart(3,'0')} — waiting at <strong>${ticket.current_service||'...'}</strong>${pos}</div>
    <div style="font-size:13px;margin-top:6px">Services: ${ticket.services ? ticket.services.join(' → ') : ''}</div>`;
  cancelBtn.style.display = 'inline-block';
  btnGet.disabled = true;
  btnGet.classList.add('disabled');
}

function showToast(text, ms=4000){
  toast.textContent = text;
  toast.style.display = 'block';
  clearTimeout(toast._t);
  toast._t = setTimeout(()=> toast.style.display='none', ms);
}

function beep(){
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine';
    o.frequency.value = 880;
    g.gain.value = 0.02;
    o.connect(g); g.connect(ctx.destination);
    o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, 220);
  }catch(e){}
}

/* ------------------ create ticket ------------------ */
btnGet.addEventListener('click', async function(){
  if(loadTicket()){
    alert('You already have a ticket. Cancel it first or wait until it is completed.');
    return;
  }
  const btn = btnGet;
  const name = document.getElementById('name').value.trim();
  const quer = document.getElementById('quer').value;
  const services = getSelectedOrderedServices();
  if (!services.length) { alert('Please select at least one service'); return; }

  btn.disabled = true; btn.classList.add('disabled');
  try {
    const resp = await fetch(API + '/ticket', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, services, quer_type: quer })
    });
    const d = await (resp.ok ? resp.json() : resp.json().catch(()=>({error:resp.statusText})));
    if (!resp.ok) { alert('Failed: ' + (d.error || d.detail || resp.statusText)); return; }

    // normalize server-provided index (handles 1-based vs 0-based)
    const normalizedIndex = normalizeIndex(d.service_index, d.services || services);

    const ticket = {
      id: d.id,
      services: Array.isArray(d.services) ? d.services : (services || []),
      quer_type: d.quer_type || quer,
      service_index: (typeof normalizedIndex !== 'undefined') ? normalizedIndex : 0,
      current_service: (Array.isArray(d.services) && d.services.length) ? ( (typeof normalizedIndex !== 'undefined') ? d.services[normalizedIndex] : d.services[0]) : (services[0] || null),
      status: d.status || 'waiting',
      created_at: d.created_at || null
    };
    saveTicket(ticket);
    setUIForTicket(ticket);
    showToast(`Your token ${String(d.id).padStart(3,'0')} — keep this page open for updates`);
    await updatePositionForTicket();
  } catch (e) {
    console.error('kiosk error', e);
    alert('Network error creating token');
  } finally {
    btn.disabled = false; btn.classList.remove('disabled');
  }
});

/* ------------------ cancel ticket flow ------------------ */
async function cancelTicketFlow(id){
  try {
    let res = await fetch(`${API}/ticket/${id}`, { method: 'DELETE' });
    if(res.ok){
      showToast('Ticket cancelled');
      clearTicket(); setUIForTicket(null);
      return true;
    }

    res = await fetch(`${API}/ticket/${id}/delete`, { method: 'POST' });
    if(res.ok){
      showToast('Ticket cancelled (fallback)');
      clearTicket(); setUIForTicket(null);
      return true;
    }

    res = await fetch(`${API}/ticket/${id}/cancel`, { method: 'POST' });
    if(res.ok){
      showToast('Ticket cancelled (cancel endpoint)');
      clearTicket(); setUIForTicket(null);
      return true;
    }

    if(res.status === 401 || res.status === 403){
      alert('Cancel failed: staff credentials required. Please ask staff at the counter to cancel your ticket.');
      return false;
    }

    let text = await res.text().catch(()=> '');
    try { const j = JSON.parse(text); if(j.error) text = j.error; } catch(e){}
    alert('Cancel failed: ' + (text || res.statusText || res.status));
    return false;

  } catch(err){
    console.error('cancel error', err);
    alert('Network error while cancelling ticket');
    return false;
  }
}

cancelBtn.addEventListener('click', async () => {
  const t = loadTicket();
  if(!t) { alert('No ticket to cancel'); return; }
  if(!confirm('Cancel your ticket?')) return;
  await cancelTicketFlow(t.id);
});

/* ------------------ SSE listening ------------------ */
function startSSEForKiosk(){
  try {
    const es = new EventSource(`${API}/events`);
    es.addEventListener('open', () => console.log('SSE open'));
    es.addEventListener('error', (e) => console.warn('SSE error', e));

    const handleRaw = (e, type) => {
      let payload = null;
      try { payload = typeof e.data === 'string' ? JSON.parse(e.data) : e.data } catch(err) { payload = null; }
      handleEventPayload(payload, type);
    };

    es.addEventListener('called', e => handleRaw(e,'called'));
    es.addEventListener('moved', e => handleRaw(e,'moved'));
    es.addEventListener('reassigned', e => handleRaw(e,'reassigned'));
    es.addEventListener('served', e => handleRaw(e,'served'));
    es.addEventListener('deleted', e => handleRaw(e,'deleted'));
    es.addEventListener('created', e => {}); // noop
  } catch(err){
    console.warn('SSE not available', err);
  }
}

/* ------------------ helper: fetch authoritative ticket record ------------------ */
async function fetchTicketFromServer(id){
  try {
    const r = await fetch(`${API}/ticket/${id}`);
    if(!r.ok) return null;
    const data = await r.json();
    return data;
  } catch(e){
    console.warn('ticket fetch failed', e);
    return null;
  }
}

/* ------------------ robust event handler (uses normalized index & server fetch on served) ------------------ */
async function handleEventPayload(payload, type){
  if(!payload || typeof payload.id === 'undefined') return;
  const t = loadTicket();
  if(!t) return;
  if(payload.id !== t.id) return;

  // incorporate server services if present
  if(Array.isArray(payload.services)) t.services = payload.services;

  // normalize index included in payload if present
  if(typeof payload.service_index !== 'undefined') {
    const normalized = normalizeIndex(payload.service_index, payload.services || t.services);
    if(typeof normalized !== 'undefined') t.service_index = normalized;
  }

  // update called_service/status if present
  if(payload.called_service) t.called_service = payload.called_service;
  if(payload.status) t.status = payload.status;

  // ensure a default index
  if(typeof t.service_index === 'undefined') t.service_index = 0;

  // recompute current_service after normalization
  if(Array.isArray(t.services) && t.services.length && typeof t.service_index !== 'undefined'){
    t.current_service = t.services[Math.min(t.service_index, t.services.length - 1)] || null;
  }

  saveTicket(t);
  setUIForTicket(t);

  if(type === 'called'){
    const svc = payload.called_service || t.current_service || 'service';
    showToast(`Your token ${String(t.id).padStart(3,'0')} is called at ${svc}`);
    beep(); try{ if(navigator.vibrate) navigator.vibrate([80,40,80]); }catch(e){}
    await updatePositionForTicket();
    return;
  }

  if(type === 'moved' || type === 'reassigned'){
    // the server should ideally send service_index; if it did we already normalized above
    if(Array.isArray(t.services) && typeof t.service_index !== 'undefined'){
      t.current_service = t.services[Math.min(t.service_index, t.services.length - 1)];
    }
    saveTicket(t);
    setUIForTicket(t);
    showToast(`Your ticket moved to ${t.current_service || 'next service'}`);
    beep(); try{ if(navigator.vibrate) navigator.vibrate([40,20]); }catch(e){}
    await updatePositionForTicket();
    return;
  }

  if(type === 'served'){
    // primary approach: if payload contains a valid normalized service_index, use it
    let normalized = (typeof payload.service_index !== 'undefined') ? normalizeIndex(payload.service_index, payload.services || t.services) : undefined;
    if(typeof normalized !== 'undefined'){
      t.service_index = normalized;
      // if there are remaining services after this index then it's not final
      if(Array.isArray(t.services) && t.service_index < (t.services.length - 1)){
        t.current_service = t.services[t.service_index];
        t.status = 'waiting';
        saveTicket(t);
        setUIForTicket(t);
        showToast(`Moved to ${t.current_service}`);
        beep(); try{ if(navigator.vibrate) navigator.vibrate([40,20]); }catch(e){}
        await updatePositionForTicket();
        return;
      } else {
        // service_index points to last service -> final
        showToast('Your ticket has been served. Thank you!');
        beep(); try{ if(navigator.vibrate) navigator.vibrate([120]); }catch(e){}
        clearTicket();
        setTimeout(()=> setUIForTicket(null), 400);
        return;
      }
    }

    // fallback: fetch the authoritative ticket from the server to see current state/index
    const serverTicket = await fetchTicketFromServer(t.id);
    if(serverTicket){
      // server may use service_index 1-based; normalize it
      const srvIndex = (typeof serverTicket.service_index !== 'undefined') ? normalizeIndex(serverTicket.service_index, serverTicket.services || t.services) : undefined;
      if(typeof srvIndex !== 'undefined') {
        t.services = Array.isArray(serverTicket.services) ? serverTicket.services : t.services;
        t.service_index = srvIndex;
        t.current_service = (Array.isArray(t.services) && t.services.length) ? t.services[Math.min(t.service_index, t.services.length - 1)] : null;
        // if there are more services pending, show moved; otherwise treat as final
        if(Array.isArray(t.services) && t.service_index < (t.services.length - 1)){
          t.status = 'waiting';
          saveTicket(t);
          setUIForTicket(t);
          showToast(`Moved to ${t.current_service}`);
          beep(); try{ if(navigator.vibrate) navigator.vibrate([40,20]); }catch(e){}
          await updatePositionForTicket();
          return;
        } else {
          // final
          showToast('Your ticket has been served. Thank you!');
          beep(); try{ if(navigator.vibrate) navigator.vibrate([120]); }catch(e){}
          clearTicket();
          setTimeout(()=> setUIForTicket(null), 400);
          return;
        }
      } else {
        // server didn't provide index — check status fields to decide
        if(serverTicket.status === 'served' || serverTicket.status === 'completed' || serverTicket.status === 'done'){
          showToast('Your ticket has been served. Thank you!');
          clearTicket();
          setTimeout(()=> setUIForTicket(null), 400);
          return;
        }
        // conservative: keep ticket and wait for a moved/reassigned event
        showToast('One stage served — waiting for next update...');
        saveTicket(t); setUIForTicket(t);
        return;
      }
    }

    // if fetch failed, conservative behavior: keep the ticket and wait for next event
    showToast('Service recorded. Waiting for next update...');
    return;
  }

  if(type === 'deleted'){
    showToast('Your ticket was removed by staff.');
    clearTicket();
    setTimeout(()=> setUIForTicket(null), 400);
    return;
  }

  // generic fallback: update and refresh position
  saveTicket(t); setUIForTicket(t); await updatePositionForTicket();
}

/* ------------------ position helper (best-effort) ------------------ */
async function updatePositionForTicket(){
  const t = loadTicket();
  if(!t) return;
  try {
    const r = await fetch(`${API}/queue`);
    if(!r.ok) return;
    const q = await r.json();
    if(!Array.isArray(q)) return;

    const svc = t.current_service || (Array.isArray(t.services) && t.services[0]);
    const ourKey = t.created_at ? new Date(t.created_at).getTime() : (t.id || 0);
    let position = 1;
    for(const item of q){
      try {
        let itemServices = Array.isArray(item.services) ? item.services : (typeof item.services === 'string' ? JSON.parse(item.services||'[]') : []);
        let itemIndexRaw = (typeof item.service_index !== 'undefined' ? item.service_index : undefined);
        let itemIndex = (typeof itemIndexRaw !== 'undefined') ? normalizeIndex(itemIndexRaw, itemServices) : 0;
        const itemCur = (Array.isArray(itemServices) && itemServices.length > itemIndex) ? itemServices[itemIndex] : (item.called_service || null);
        if(!itemCur || itemCur !== svc) continue;
        if(item.id === t.id) continue;
        const itemKey = item.created_at ? new Date(item.created_at).getTime() : (item.id || 0);
        if(itemKey <= ourKey) position++;
      } catch(e){}
    }
    t._position = position;
    saveTicket(t);
    setUIForTicket(t);
  } catch(err){}
}

/* ------------------ initialization ------------------ */
(function init(){
  const t = loadTicket();
  if(t) {
    // normalize stored index
    t.service_index = normalizeIndex(t.service_index, t.services || []);
    if(!t.current_service && Array.isArray(t.services) && t.services.length) t.current_service = t.services[Math.min(t.service_index||0, (t.services.length-1))];
    saveTicket(t);
    setUIForTicket(t);
    updatePositionForTicket();
  }
  startSSEForKiosk();
  setInterval(async () => {
    if(loadTicket()) await updatePositionForTicket();
  }, POLL_INTERVAL_MS);

  bindDrag();
})();
</script>
</body>
</html>
